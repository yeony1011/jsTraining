<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div class="wrap_converter">
    <h1>텍스트 태그 생성기(Text Tag Creator)</h1>
    <div class="tag_converter">aaaabbbbccccdddd</div>
    <button type="reset" class="btn_reset">초기화</button>
  </div>
  <div class="wrap_button">
    <ul class="list_button">
      <li>
        <button type="button" class="btn_wrap">div</button>
      </li>
      <li>
        <button type="button" class="btn_wrap">span</button>
      </li>
      <li>
        <button type="button" class="btn_wrap">strong</button>
      </li>
      <li>
        <button type="button" class="btn_wrap">p</button>
      </li>
    </ul>
  </div>
  <script>
    // DOM 요소 참조
    const tagConverter = document.querySelector('.tag_converter');

    /**
     * 컨텐츠 초기화
     * - HTML 태그를 제거하고 순수 텍스트만 남김
     */
    function resetContent(){
      tagConverter.innerText = tagConverter.textContent;
    }

    /**
     * 선택된 텍스트 범위 정보 가져오기
     * @returns {Object|null} {startOffset, endOffset, selectedText} 또는 null
     * 
     * 알고리즘 1단계: 텍스트 선택 확인 및 범위 정보 추출
     * 
     * [이 함수가 하는 일]
     * 1. 사용자가 텍스트를 선택했는지 확인
     * 2. 선택이 올바른 요소 내부에 있는지 확인
     * 3. 선택의 시작 위치, 끝 위치, 선택된 텍스트를 반환
     */
    function getSelectedRange() {
      // ===== Step 1: Selection 객체 가져오기 =====
      // window.getSelection(): 현재 사용자가 선택한 텍스트 정보를 가져옴
      // 예: 사용자가 "bbbb"를 드래그해서 선택했다면
      const selection = window.getSelection();
      
      // ===== Step 2: 선택이 있는지 확인 =====
      // rangeCount: 선택된 범위(Range)의 개수
      // - 0이면: 선택 없음 (사용자가 아무것도 선택하지 않음)
      // - 1이면: 일반적인 선택 (대부분의 경우)
      // 
      // ⚠️ 왜 이걸 체크해야 하나요?
      // anchorOffset과 focusOffset은 선택이 없어도 0을 반환해서
      // 선택이 없을 때와 시작 위치가 0일 때를 구분할 수 없음
      if (!selection || selection.rangeCount === 0) {
        return null;  // "선택 없음"을 명확하게 표현
      }

      // ===== Step 3: Range 객체 가져오기 =====
      // Range 객체: 선택 범위의 정확한 정보를 담고 있는 객체
      // getRangeAt(0): 첫 번째 선택 범위를 가져옴
      // 
      // Range 객체에는 이런 정보가 들어있음:
      // - startOffset: 선택의 시작 위치 (문자 단위)
      // - endOffset: 선택의 끝 위치 (문자 단위)
      // - startContainer: 선택이 시작된 노드
      // - endContainer: 선택이 끝난 노드
      // - toString(): 선택된 텍스트를 문자열로 반환
      const range = selection.getRangeAt(0);
      
      // ===== Step 4: 선택이 올바른 요소에 있는지 확인 =====
      // commonAncestorContainer: 선택의 시작과 끝을 모두 포함하는 가장 가까운 부모 요소
      // 
      // 예시:
      // HTML: <div class="tag_converter">aaaabbbb</div>
      // 사용자가 "bbbb"를 선택했다면:
      // - commonAncestorContainer = 텍스트 노드 "aaaabbbb"
      // - tagConverter.contains() = true ✅
      //
      // 하지만 사용자가 버튼의 "div" 텍스트를 선택했다면:
      // - commonAncestorContainer = 버튼 요소
      // - tagConverter.contains() = false ❌ (잘못된 선택!)
      if (!tagConverter.contains(range.commonAncestorContainer)) {
        return null;  // "잘못된 위치 선택"을 명확하게 표현
      }

      // ===== Step 5: 위치 정보 가져오기 =====
      // startOffset: 선택의 시작 위치 (몇 번째 글자인지)
      // endOffset: 선택의 끝 위치 (몇 번째 글자인지)
      // 
      // 예시: "aaaabbbbcccc"에서 "bbbb" 선택
      // - startOffset = 4 (5번째 글자부터)
      // - endOffset = 8 (9번째 글자까지)
      const startOffset = range.startOffset;
      const endOffset = range.endOffset;
      
      // ===== Step 6: 역방향 선택 처리 =====
      // 사용자가 왼쪽에서 오른쪽으로 드래그: startOffset < endOffset ✅
      // 사용자가 오른쪽에서 왼쪽으로 드래그: startOffset > endOffset ⚠️
      // 
      // Math.min/max를 사용해서 항상 start < end가 되도록 정규화
      // 예: startOffset=8, endOffset=4 → start=4, end=8로 변환
      const start = Math.min(startOffset, endOffset);
      const end = Math.max(startOffset, endOffset);

      // ===== Step 7: 선택된 텍스트 추출 =====
      // toString(): Range 객체에서 선택된 텍스트를 문자열로 가져옴
      // 예: "bbbb"를 선택했다면 "bbbb" 반환
      const selectedText = range.toString();

      // ===== Step 8: 정보를 객체로 반환 =====
      // 이렇게 객체로 반환하면 여러 값을 한번에 전달할 수 있음
      return {
        startOffset: start,      // 시작 위치
        endOffset: end,          // 끝 위치
        selectedText: selectedText  // 선택된 텍스트
      };
    }

    /**
     * 텍스트를 HTML 태그로 감싸기
     * @param {string} tagName - 감쌀 태그 이름
     * @param {string} text - 감쌀 텍스트
     * @returns {string} - 감싸진 HTML 문자열
     * 
     * 알고리즘 2단계: 태그로 감싸기
     */
    function wrapWithTag(tagName, text) {
      return `<${tagName}>${text}</${tagName}>`;
    }

    /**
     * 컨텐츠 변경
     * @param {Event} event - 클릭 이벤트 객체
     * 
     * 알고리즘 흐름:
     * 1. 선택된 텍스트 범위 정보 가져오기
     * 2. 선택이 없으면 경고 메시지 표시
     * 3. 버튼에서 태그 이름 가져오기
     * 4. 현재 텍스트 내용 가져오기
     * 5. 선택된 부분을 태그로 감싸기
     * 6. HTML 업데이트 및 선택 해제
     */
    function updateContent(event) {
      // ===== 알고리즘 1단계: 텍스트 선택 확인 및 범위 정보 추출 =====
      // getSelectedRange() 함수를 호출해서 선택 정보 가져오기
      // 반환값 예시: { startOffset: 4, endOffset: 8, selectedText: "bbbb" }
      // 만약 선택이 없으면 null 반환
      const rangeInfo = getSelectedRange();
      
      // ===== 알고리즘 2단계: 선택이 없으면 경고 메시지 표시 =====
      // rangeInfo가 null이거나 선택된 텍스트가 없으면 (공백만 선택한 경우)
      // 사용자에게 경고하고 함수 종료
      // 
      // ⚠️ 왜 이렇게 체크하나요?
      // - rangeInfo === null: getSelectedRange()에서 선택 없음을 의미
      // - !rangeInfo.selectedText.trim(): 공백만 선택한 경우도 체크
      if (!rangeInfo || !rangeInfo.selectedText.trim()) {
        alert('텍스트를 선택해주세요.');
        return;  // 함수 종료 (더 이상 실행 안 함)
      }

      // ===== 알고리즘 3단계: 버튼에서 태그 이름 가져오기 =====
      // event.target: 클릭한 버튼 요소
      // innerText: 버튼 안의 텍스트 (예: "strong", "div", "span")
      // trim(): 앞뒤 공백 제거
      const tagName = event.target.innerText.trim();
      
      // 태그 이름이 없으면 에러
      if (!tagName) {
        alert('태그 이름을 가져올 수 없습니다.');
        return;
      }

      // ===== 알고리즘 4단계: 현재 텍스트 내용 가져오기 =====
      // textContent: HTML 태그를 제거하고 순수 텍스트만 가져옴
      // 예: "<strong>bbbb</strong>" → "bbbb"
      // 
      // ⚠️ 왜 textContent를 사용하나요?
      // - innerText: 보이는 텍스트만 (CSS로 숨겨진 텍스트 제외)
      // - textContent: 모든 텍스트 (CSS 무시, 더 예측 가능)
      const currentText = tagConverter.textContent;
      
      // 구조 분해 할당: 객체에서 값 추출
      // rangeInfo.startOffset → startOffset
      // rangeInfo.endOffset → endOffset
      // rangeInfo.selectedText → selectedText
      const { startOffset, endOffset, selectedText } = rangeInfo;

      // ===== 선택 범위 유효성 검사 =====
      // 선택 위치가 올바른지 확인
      // - startOffset < 0: 음수는 불가능
      // - endOffset > currentText.length: 텍스트 길이를 넘으면 안 됨
      // - startOffset >= endOffset: 시작이 끝보다 크거나 같으면 안 됨
      if (startOffset < 0 || endOffset > currentText.length || startOffset >= endOffset) {
        alert('유효하지 않은 선택 범위입니다.');
        return;
      }

      // ===== 알고리즘 5단계: 선택된 부분을 태그로 감싸기 =====
      // slice(시작, 끝): 문자열에서 특정 부분만 가져오기
      // 
      // 예시: "aaaabbbbccccdddd"에서 "bbbb" 선택 (startOffset=4, endOffset=8)
      // - beforeText = currentText.slice(0, 4) = "aaaa"
      // - afterText = currentText.slice(8) = "ccccdddd" (끝 생략하면 끝까지)
      // - selectedText = "bbbb"
      const beforeText = currentText.slice(0, startOffset);
      const afterText = currentText.slice(endOffset);
      
      // wrapWithTag() 함수로 태그 감싸기
      // 예: wrapWithTag('strong', 'bbbb') → "<strong>bbbb</strong>"
      const wrappedText = wrapWithTag(tagName, selectedText);

      // ===== 알고리즘 6단계: HTML 업데이트 =====
      // innerHTML: 요소의 HTML 내용을 변경
      // 
      // 텍스트 조합:
      // beforeText + wrappedText + afterText
      // = "aaaa" + "<strong>bbbb</strong>" + "ccccdddd"
      // = "aaaa<strong>bbbb</strong>ccccdddd"
      tagConverter.innerHTML = beforeText + wrappedText + afterText;

      // ===== 선택 해제 (사용자 경험 개선) =====
      // removeAllRanges(): 모든 선택 범위를 제거 (선택 해제)
      // 작업 완료 후 선택이 남아있으면 보기 안 좋으니까 해제
      window.getSelection().removeAllRanges();
    }

    /**
     * 이벤트 연결
     */
    function bindEvents(){
      const btnWrap = document.querySelectorAll('.btn_wrap');
      btnWrap.forEach((btn) => {
        btn.addEventListener('click', updateContent);
      });

      const btnReset = document.querySelector('.btn_reset');
      btnReset.addEventListener('click', resetContent);
    }

    /**
     * 초기화
     */
    function init(){
      bindEvents();
    }

    init();
  </script>
</body>
</html>